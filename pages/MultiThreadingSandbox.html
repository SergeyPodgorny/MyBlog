<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../styles/style1.css">
    <title>Multithreading Sandbox</title>
</head>
<body>


    <div>#НаКоленке</div><br>

    <a href="../index.html">на главную </a>

    <h2><a href="https://github.com/SergeyPodgorny/Multithreading-sandbox" target=»_blank»>Multithreading Sandbox </a></h2>

    <h3>Стэк технологий: Java 8, Eclipse IDE, Git, Lambda expressions, Concurency: java.util.concurent (Thread, Runnable, Callable), Executors, Fork/Join Framework, Maven</h3>

    <h4><div> Это репозиторий предназначен для двух вещей:</div><br></h4>

    <ul>
        <li>Здесь я тестирую различные подходы по организации многопоточности для обеспечения как можно более быстрого заполнения матрицы коэффициентов 
            для решения дифференциальнго уравнения сохранения энергии, которое является ядром собственно разработанного алгоритма мгновенного расчета 
            температурного поля в активной зоне ядерного реактора типа PWR, входящего в состав приложения <a href="./pages/webCFDapp-for-PWR.html">webCFDapp</a> 
            (в данном случае речь идет о двумерном массиве, в котором около 5,7 млн элементов). </li><br>
        <li>Изучаю всё, что связано с многопточным программированием в Java.</li>
    </ul>
    
    <h3>Выводы и наблюдения по поиску оптимального способоа заполнения матрицы коэффициентов</h3><br>

    <ul>
        


        <li>По состоянию на 24.03.2022 заполнение матрицы коэффициентов выполнено следующими способами:
            <ul>
                <li>Заполнение матрицы в одном потоке; среднее время - 114 мс.</li>
                <li>Заполнение матрицы с использованием класса Thread (в данном случае создается 7 потоков для каждой подзадачи, в общем оптимизация хромает). 
                    Худшее время - 59 мс, лучшее время - 38 мс.</li>
                <li>Заполнение матрциы с использованием класса Thread и применении паттерна Factory. 
                    Неожиданно, но это самый худший результат из всех. Среднее время - 250 мс.</li>
                <li>Заполнение матрциы с использованием класса Executors показывает 
                    превосходные результаты (наилучший результат показывает создание двух потоков). Среднее время - 18 мс.</li>
                <li>В планах ознакомится с Fork/Join framework. </li>
            </ul>
            
          
    </ul>




    <h3>Что изучено по многопоточному програмированию в Java</h3><br>
   
   <ul>
    <li>По состоянию на 19.04.2022 изучено следующее:
        <ul>
            <li>Изучены разные способы создания потоков с помощью класса Thread.</li>
            <li>Изучены манипуляции с жизненным циклом потоков.</li>
            <li>Проверена на практике необходимость синхронизации потоков. Изучена синхронизация 
                статичных и нестатичных методов, а также блоков кода в статичных и нестатичных методах.</li>
            <li>Изучена синхронизация Runnable задач при помощи статичных блоков кода.</li>
            <li>Разобраны примеры с Volatile, а также Happens before принцип.</li>
            <li>Atomic numbers and operations.</li>
            <li>DeadLock problem.</li>
            <li>Как пользоваться методами wait/notify.</li>
            <li> Этот раздел будет заполняться по мере систематизации своих знаний.</li>
        </ul>
        
      
</ul>


</body>
</html>